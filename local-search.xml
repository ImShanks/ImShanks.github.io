<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java进阶-IO流</title>
    <link href="/2023/11/09/Java%E8%BF%9B%E9%98%B6-IO%E6%B5%81/"/>
    <url>/2023/11/09/Java%E8%BF%9B%E9%98%B6-IO%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h2 id="一、File类"><a href="#一、File类" class="headerlink" title="一、File类"></a>一、File类</h2><p>1.绝对路径：以windows操作系统为例，包括盘符在内的文件或文件目录的完整路径。</p><p>2.相对路径：相对于某一个文件目录来讲的相对的位置</p><ul><li>在IDEA中，如果使用单元测试方法，相对于当前的module来讲</li><li>​  如果是在main方法中：相对于当前的project来讲</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>IO流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis进阶</title>
    <link href="/2023/11/08/redis%E8%BF%9B%E9%98%B6/"/>
    <url>/2023/11/08/redis%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Redis持久化"><a href="#一、Redis持久化" class="headerlink" title="一、Redis持久化"></a>一、Redis持久化</h2><h3 id="1-RDB"><a href="#1-RDB" class="headerlink" title="1.RDB"></a>1.RDB</h3><p>RDB全称Redis Database Backup file (Redis数据备份文件)，也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。</p><p>快照文件称为RDB文件，默认是保存在当前运行目录。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">save <span class="token comment">#由Redis主进程来执行RDB，会阻塞所有命令</span>bgsave <span class="token comment">#开启子进程执行RDB，避免主进程受到影响</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>Redis停机前会执行一次RDB</p><h4 id="1-1-bgsave"><a href="#1-1-bgsave" class="headerlink" title="1.1 bgsave"></a>1.1 bgsave</h4><p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB文件。</p><p>fork采用的是copy-on-write技术</p><ul><li>当主进程执行读操作时，访问共享内存</li><li>当主进程执行写操作时，则会拷贝一份数据，执行写操作</li></ul><p><img src="/2023/11/08/redis%E8%BF%9B%E9%98%B6/image-20231108190726167.png" alt="image-20231108190726167"></p><h3 id="2-AOF"><a href="#2-AOF" class="headerlink" title="2.AOF"></a>2.AOF</h3><p>AOF全称为Append 0nly File (追加文件)。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p><p><img src="/2023/11/08/redis%E8%BF%9B%E9%98%B6/image-20231108193503288.png" alt="image-20231108193503288"></p><p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#是否开启AOF功能，默认是no</span>appendonly <span class="token function">yes</span><span class="token comment"># AOF文件的名称"</span>appendfilename  <span class="token string">"appendonly.aof"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>AOF的命令记录的频率也可以通过redis.conf文件来配</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#表示每执行一次写命令，立即记录到AOF文件</span>appendfsync always<span class="token comment"># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span>appendfsync everysec<span class="token comment">#写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span>appendfsync no<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><img src="/2023/11/08/redis%E8%BF%9B%E9%98%B6/image-20231108200721665.png" alt="image-20231108200721665"></p><h4 id="2-1-bgrewriteaof"><a href="#2-1-bgrewriteaof" class="headerlink" title="2.1  bgrewriteaof"></a>2.1  bgrewriteaof</h4><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p><p><img src="/2023/11/08/redis%E8%BF%9B%E9%98%B6/image-20231108201202419.png" alt="image-20231108201202419"></p><h3 id="3-AOF和RDB对比"><a href="#3-AOF和RDB对比" class="headerlink" title="3.AOF和RDB对比"></a>3.AOF和RDB对比</h3><p><img src="/2023/11/08/redis%E8%BF%9B%E9%98%B6/image-20231108201411092.png" alt="image-20231108201411092"></p><h2 id="二、Redis主从"><a href="#二、Redis主从" class="headerlink" title="二、Redis主从"></a>二、Redis主从</h2><h3 id="1-数据同步原理"><a href="#1-数据同步原理" class="headerlink" title="1.数据同步原理"></a>1.数据同步原理</h3><p>主从的第一次同步是全量同步：</p><p><img src="/2023/11/08/redis%E8%BF%9B%E9%98%B6/image-20231108203347471.png" alt="image-20231108203347471"></p><p>master如何判断slave是不是第一次来同步数据? 这里会用到两个很重要的概念:</p><ul><li>Replication d:简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replidslave则会继承master节点的replid</li><li>offset:偏移量，随着记录在repl baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset.如果slave的offset小于master的offset，说明slave数据落后于master，需要更新</li></ul><p>因此slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据</p><p><img src="/2023/11/08/redis%E8%BF%9B%E9%98%B6/image-20231108203841860.png" alt="image-20231108203841860"></p><h3 id="2-增量同步原理"><a href="#2-增量同步原理" class="headerlink" title="2.增量同步原理"></a>2.增量同步原理</h3><p>主从第一次同步是全量同步但如果slave重启后同步，则执行增量同步</p><p><img src="/2023/11/08/redis%E8%BF%9B%E9%98%B6/image-20231108205030363.png" alt="image-20231108205030363"></p><h3 id="3-优化redis主从同步集群："><a href="#3-优化redis主从同步集群：" class="headerlink" title="3.优化redis主从同步集群："></a>3.优化redis主从同步集群：</h3><ul><li>在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘10。</li><li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘I0</li><li>适当提高repl baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</li><li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力</li></ul><p><img src="/2023/11/08/redis%E8%BF%9B%E9%98%B6/image-20231108205246131.png" alt="image-20231108205246131"></p><h2 id="三、Redis哨兵"><a href="#三、Redis哨兵" class="headerlink" title="三、Redis哨兵"></a>三、Redis哨兵</h2><h3 id="1-哨兵的作用"><a href="#1-哨兵的作用" class="headerlink" title="1.哨兵的作用"></a>1.哨兵的作用</h3><p>Redis提供了哨兵(Sentinel) 机制来实现主从集群的自动故障恢复。哨兵的结构和作用如下：</p><ul><li><strong>监控:</strong> Sentinel会不断检查您的master和slave是否按预期工作</li><li>**自动故障恢复:**如果master故障，Sentinel会将个slave提升为master。当故障实例恢复后也以新的master为主</li><li>**通知:**Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</li></ul><p><img src="/2023/11/08/redis%E8%BF%9B%E9%98%B6/image-20231108205714403.png" alt="image-20231108205714403"></p><h3 id="2-服务状态监控"><a href="#2-服务状态监控" class="headerlink" title="2.服务状态监控"></a>2.服务状态监控</h3><p>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令:</p><ul><li>主观下线:如果某sentinel节点发现某实例未在规定时间响应，则认为该实例主观下线</li><li>客观下线:若超过指定数量(quorum)的sentinel都认为该实例主观下线，则该实例客观下线。quorum值最好超过Sentinel实例数量的一半。</li></ul><p><img src="/2023/11/08/redis%E8%BF%9B%E9%98%B6/image-20231108205851624.png" alt="image-20231108205851624"></p><h3 id="3-选举新的master"><a href="#3-选举新的master" class="headerlink" title="3.选举新的master"></a>3.选举新的master</h3><p>一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的:</p><ul><li>首先会判断slave节点与mater节点断开时间长短，如果超过指定值(down-after-milliseconds* 10)则会排除该slave节点</li><li>然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举</li><li>如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</li><li>最后是判断slave节点的运行id大小，越小优先级越高。</li></ul><h3 id="4-如何实现故障转移"><a href="#4-如何实现故障转移" class="headerlink" title="4.如何实现故障转移"></a>4.如何实现故障转移</h3><p>当选中了其中一个slave为新的master后 (例如slave1)，故障的转移的步骤如下：</p><ul><li>sentinel给备选的slave1节点发送slaveof no one命令，让该节点成为master。</li><li>sentinel给所有其它slave发送slaveof192.1681501017002命令，让这些slave成为新master的从节点，开始从新的master上同步数据。</li><li>最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点。</li></ul><p><img src="/2023/11/08/redis%E8%BF%9B%E9%98%B6/image-20231108210241329.png" alt="image-20231108210241329"></p>]]></content>
    
    
    <categories>
      
      <category>缓存数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-进阶篇</title>
    <link href="/2023/10/28/MySQL-%E8%BF%9B%E9%98%B6%E7%AF%87/"/>
    <url>/2023/10/28/MySQL-%E8%BF%9B%E9%98%B6%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h3 id="一-MyISAM和InnoDB区别"><a href="#一-MyISAM和InnoDB区别" class="headerlink" title="一.MyISAM和InnoDB区别"></a>一.MyISAM和InnoDB区别</h3><ul><li><p>InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。</p></li><li><p>MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。</p></li><li><p>MyISAM 不支持外键，而 InnoDB 支持。</p></li><li><p>MyISAM 不支持 MVCC，而 InnoDB 支持。</p></li><li><p>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</p></li><li><p>MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</p></li><li><p>InnoDB 的性能比 MyISAM 更强大。</p></li><li><p><strong>lnnoDB</strong>:是Mysal的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。</p></li><li><p><strong>MyISAM</strong>:如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。    MyISAM目前有替换品MongoDB</p></li><li><p><strong>MEMORY</strong>:将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。   MEMORY目前也有替换品那就是Redis</p></li></ul><h3 id="二-索引"><a href="#二-索引" class="headerlink" title="二.索引"></a>二.索引</h3><h4 id="1：索引的概念"><a href="#1：索引的概念" class="headerlink" title="1：索引的概念"></a>1：索引的概念</h4><p>索引(index)是帮助MySQL高效获取数据的数据结构(有序。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><ul><li>索引会占据磁盘空间，索引可以提高查询效率，但是会降低更新数据的效率</li></ul><h4 id="2：索引的结构"><a href="#2：索引的结构" class="headerlink" title="2：索引的结构"></a>2：索引的结构</h4><p>按照数据结构维度划分：</p><ul><li>B+Tree 索引：MySQL 里默认和最常用的索引类型。只有叶子节点存储 value，非叶子节点只有指针和 key。存储引擎 MyISAM 和 InnoDB 实现 BTree 索引都是使用 B+Tree，但二者实现方式不一样（前面已经介绍了）。</li><li>哈希索引：类似键值对的形式，一次即可定位。</li><li>R-Tree 索引（空间索引）：一般不会使用，仅支持 geometry 数据类型，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li><li>全文索引：对文本的内容进行分词，进行搜索。目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li></ul><p>按照底层存储方式角度划分：</p><ul><li>聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。  <strong>聚集索引指向的是数据</strong></li><li>非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。  <strong>二级索引指向的是索引</strong></li></ul><p>按照应用维度划分：</p><ul><li>主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。</li><li>普通索引：仅加速查询。</li><li>唯一索引：加速查询 + 列值唯一（可以有 NULL）。</li><li>覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。</li><li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</li><li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li></ul><p><img src="/2023/10/28/MySQL-%E8%BF%9B%E9%98%B6%E7%AF%87/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230922210947.png"></p><h4 id="3-InnoDB的默认索引结构是什么？（面试问过）"><a href="#3-InnoDB的默认索引结构是什么？（面试问过）" class="headerlink" title="3.InnoDB的默认索引结构是什么？（面试问过）"></a>3.InnoDB的默认索引结构是什么？（面试问过）</h4><p>InnoDB 存储引擎的默认索引结构是B+树（B-tree），它用于加速数据库表的查询操作。这种索引结构支持高效的数据插入、删除和查找操作，是MySQL中常用的索引类型之一。</p><p>为什么不用B树要用B+树？</p><ul><li><strong>更适合范围查询</strong>：B+树的叶子节点都连接成一个有序链表，这使得范围查询非常高效，因为数据在物理存储上是有序的。而B树在范围查询时可能需要进行额外的跳跃操作，效率较低。</li><li><strong>更好的磁盘IO性能</strong>：B+树的树高相对较低，因此在进行插入和删除操作时需要更少的磁盘IO。B树在树高相对较高时可能需要更多的IO操作，这会降低性能。</li><li><strong>更好的顺序访问性能</strong>：由于B+树的叶子节点形成有序链表，顺序访问数据更加高效。这对于某些查询和扫描操作非常重要。</li><li><strong>索引占用更少的内存</strong>：B+树的内部节点不保存数据记录的引用，只保存键值和子节点的信息，因此相比于B树，B+树索引占用更少的内存。</li></ul><h3 id="三-索引失效的情况"><a href="#三-索引失效的情况" class="headerlink" title="三.索引失效的情况"></a>三.索引失效的情况</h3><ol><li><strong>未使用索引列</strong>：当查询中的条件不是索引列时，索引将失效。例如，如果你有一个名为”age”的索引，但查询是基于名字而不是年龄的，索引将无效。</li><li><strong>使用函数或表达式</strong>：如果在查询中对列使用函数、表达式或计算，索引可能会失效。例如，<code>WHERE YEAR(date_column) = 2023</code> 可能导致索引失效，因为它对日期列进行了函数计算。</li><li><strong>模糊查询</strong>：模糊查询（如使用通配符%）通常会导致索引失效，因为数据库无法有效地利用索引来匹配通配符的位置。</li><li><strong>不等于条件</strong>：在某些情况下，使用不等于条件（例如，<code>!=</code> 或 <code>&lt;&gt;</code>）可能导致索引失效，因为它们不是等值条件。</li><li><strong>OR条件</strong>：包含多个OR条件的查询可能会导致索引失效，特别是这些条件没有被合理地组织。</li><li><strong>列顺序</strong>：索引的列顺序也很重要。如果查询的列顺序与索引的列顺序不匹配，索引可能会失效。</li><li><strong>大数据范围查询</strong>：在大数据表上执行范围查询（例如，大于、小于、介于等）可能会导致索引失效，因为数据库可能需要扫描大量的索引页。</li></ol><p>解决索引失效的方法包括：</p><ul><li>确保查询中使用了适当的索引列，并避免在索引列上使用函数或表达式。</li><li>优化查询语句，尽量避免模糊查询和OR条件。</li><li>确保索引的列顺序与查询中的列顺序匹配。</li><li>使用合适的索引类型（例如，B-tree、Hash、Full-text等），取决于查询的需求。</li><li>定期重新评估数据库的索引策略，根据实际查询模式进行调整</li></ul><h3 id="四、SQL优化"><a href="#四、SQL优化" class="headerlink" title="四、SQL优化"></a>四、SQL优化</h3><h4 id="1-insert优化"><a href="#1-insert优化" class="headerlink" title="1.insert优化"></a>1.insert优化</h4><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#批量插入Insert into tb test values(1,&#39;Tom&#39;),(2,&#39;Cat&#39;),(3,erry&#39;);# 手动提交事务                                    start transaction:insert into tb_test values(1,&#39;Tom&#39;),(2,&#39;Cat&#39;),(3,Jerry&#39;);insert into tb_test values(4,&#39;Tom&#39;),(5,&#39;Cat&#39;),(6,Jerry&#39;);                                    insert into tb_test values(7,&#39;Tom&#39;),(8,&#39;Cat&#39;),(9,erry&#39;);commit;#主键顺序插入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>1.1<strong>大批量插入数据:</strong></p><p>如果一次性需要插入大批量数据，使用inset语句插入性能较低，此时可以使用MySOL数据库提供的load指令进行插入。操作如下:</p><p><img src="/2023/10/28/MySQL-%E8%BF%9B%E9%98%B6%E7%AF%87/image-20231108211530851.png" alt="image-20231108211530851"></p><p><img src="/2023/10/28/MySQL-%E8%BF%9B%E9%98%B6%E7%AF%87/image-20231108211703774.png" alt="image-20231108211703774"></p><h4 id="2-主键优化"><a href="#2-主键优化" class="headerlink" title="2.主键优化"></a>2.主键优化</h4><p><img src="/2023/10/28/MySQL-%E8%BF%9B%E9%98%B6%E7%AF%87/image-20231108212004326.png" alt="image-20231108212004326"></p><ul><li><p><strong>页分裂</strong></p><ul><li>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据多大，会行溢出)，根据主键排列。</li></ul><p><img src="/2023/10/28/MySQL-%E8%BF%9B%E9%98%B6%E7%AF%87/image-20231108212152281.png" alt="image-20231108212152281"></p><p><img src="/2023/10/28/MySQL-%E8%BF%9B%E9%98%B6%E7%AF%87/image-20231108212256058.png" alt="image-20231108212256058"></p></li><li><p><strong>页合并</strong></p><ul><li>当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记(flaged)为删除并且它的空间变得允许被其他记录声明使用。</li><li>当页中删除的记录达到 MERGE THRESHOLD(默认为页的50%)，nnoDB会开始寻找最靠近的页(前或后)看看是否可以将两个页合并以优化空间使用。</li></ul></li></ul><p><strong>主键设计原则</strong></p><ul><li>满足业务需求的情况下，尽量降低主键的长度</li><li>插入数据时，尽量选择顺序插入，选择使用AUTO INCREMENT自增主键</li><li>尽量不要使用UUID做主键或者是其他自然主键，如身份证号</li><li>业务操作时，尽量减少对主键的修改</li></ul><h4 id="3-order-by优化"><a href="#3-order-by优化" class="headerlink" title="3.order by优化"></a>3.order by优化</h4><ul><li>Using filesort:通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort排序</li><li>Using index:通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要额外排序，操作效率高。</li></ul><p><img src="/2023/10/28/MySQL-%E8%BF%9B%E9%98%B6%E7%AF%87/image-20231108213117868.png" alt="image-20231108213117868"></p><p><img src="/2023/10/28/MySQL-%E8%BF%9B%E9%98%B6%E7%AF%87/image-20231108213131153.png" alt="image-20231108213131153"></p><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</li><li>尽量使用覆盖索引。</li><li>多字段排序,一个升序一个降序，此时需要注意联合索引在创建时的规则(ASC&#x2F;DESC)。</li><li>如果不可避免的出现filesot，大数据量排序时，可以适当增大排序缓冲区大小 sort buffer size(默认256k)。</li></ul><h4 id="4-group-by-优化"><a href="#4-group-by-优化" class="headerlink" title="4.group by 优化"></a>4.group by 优化</h4><p><img src="/2023/10/28/MySQL-%E8%BF%9B%E9%98%B6%E7%AF%87/image-20231108213733246.png" alt="image-20231108213733246"></p><h4 id="5-limit优化"><a href="#5-limit优化" class="headerlink" title="5.limit优化"></a>5.limit优化</h4><p><img src="/2023/10/28/MySQL-%E8%BF%9B%E9%98%B6%E7%AF%87/image-20231108214100629.png" alt="image-20231108214100629"></p><h4 id="6-count优化"><a href="#6-count优化" class="headerlink" title="6.count优化"></a>6.count优化</h4><ul><li>MYISAM引擎把一个表的总行数存在了磁盘上，因此执行count(<em>)的时候会直接返回这个数，效率很高</em></li><li><em>innoDB引擎就麻烦了，它执行 count(</em>)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li><li>优化思路: 自己计数。</li></ul><h4 id="7-update优化"><a href="#7-update优化" class="headerlink" title="7.update优化"></a>7.update优化</h4><p><img src="/2023/10/28/MySQL-%E8%BF%9B%E9%98%B6%E7%AF%87/image-20231108215023149.png" alt="image-20231108215023149"></p><h3 id="五、锁"><a href="#五、锁" class="headerlink" title="五、锁"></a>五、锁</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><ul><li>介绍<ul><li>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源(CPU、RAM、I&#x2F;O)的争用以外，数据也是-种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</li></ul></li><li>分类<ul><li>全局锁:锁定数据库中的所有表</li><li>表级锁:每次操作锁住整张表。</li><li>行级锁:每次操作锁住对应的行数据</li></ul></li></ul><h4 id="2-全局锁"><a href="#2-全局锁" class="headerlink" title="2.全局锁"></a>2.全局锁</h4><ul><li><p>介绍</p><ul><li><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。</p></li><li><p>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p></li></ul></li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#加全局锁语句flush tables with read lock;#备份mysqldump -u root -p 123456 itcast &gt; itcast.sql#解锁unlock tables;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><ul><li><p>特点</p><p>数据库中加全局锁，是一个比较重的操作，存在以下问题:</p><ul><li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆</li><li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志(binlog)，会导致主从延迟</li></ul></li></ul><h4 id="3-表级锁"><a href="#3-表级锁" class="headerlink" title="3.表级锁"></a>3.表级锁</h4><p>介绍</p><p>表级锁，每次操作锁住整张表。锁定细粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM，InnoDB，BDB等存储引擎中。</p><p>对于表级锁，主要分为一下三类：</p><ul><li>表锁<ol><li>表共享读锁(read lock)</li><li>表独占写锁(write lock)</li></ol></li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#表加锁(读锁)只能读lock tables socre read;#表解锁unlock tables;#表加锁(写锁) 当前客户端可以读写，其他客户端不能读写lock tables socre write;#表解锁unlock tables;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><img src="/2023/10/28/MySQL-%E8%BF%9B%E9%98%B6%E7%AF%87/image-20231109144554516.png" alt="image-20231109144554516"></p><ul><li>元数据锁</li></ul><p>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表<br>上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性。</p><p>在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)，当对表结构进行变更操作的时候，加MDL写锁(排他)。</p><p><img src="/2023/10/28/MySQL-%E8%BF%9B%E9%98%B6%E7%AF%87/image-20231109144712930.png" alt="image-20231109144712930"></p><ul><li>意向锁</li></ul><ol><li>意向共享锁 (IS): 由语句 select …lock in share mode添加。</li><li>意向排他锁 (IX) : 由insert、update、delete、select …for update 添加。</li></ol><h4 id="4-行级锁"><a href="#4-行级锁" class="headerlink" title="4.行级锁"></a>4.行级锁</h4><ul><li>介绍</li></ul><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。</p><p>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类</p><ul><li>行锁(Record Lock): 锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。</li><li>间隙锁(Gap lock):锁定索引记录间隙(不含该记录)，确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持</li><li>临键锁(Next-KeyLock):行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。</li></ul><p>行锁</p><p>InnoDB实现了以下两种类型的行锁:</p><ol><li>共享锁(S):允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li><li>排他锁(X):允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</li></ol><p><img src="/2023/10/28/MySQL-%E8%BF%9B%E9%98%B6%E7%AF%87/image-20231109152233799.png" alt="image-20231109152233799"></p><p><img src="/2023/10/28/MySQL-%E8%BF%9B%E9%98%B6%E7%AF%87/image-20231109161227579.png" alt="image-20231109161227579"></p><ul><li><p>行锁-演示</p><ul><li>默认情况下，innoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁</li><li>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么innoDB将对表中的所有记录加锁，此时 就会升级为表锁。</li></ul></li><li><p>间隙锁&#x2F;临键锁-演示</p><p>默认情况下，innoDB在 REPEATABLE READ事务隔离级别运行，lnnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读，</p><ul><li>索引上的等值查询(唯一索引)，给不存在的记录加锁时，优化为间隙锁</li><li>索引上的等值查询(普通索引)，向右遍历时最后一个值不满足查询需求时，next-keylock 退化为间隙锁</li><li>索引上的范围查询(唯一索引)，会访问到不满足条件的第一个值为止。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-基础篇</title>
    <link href="/2023/10/28/MySQL-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <url>/2023/10/28/MySQL-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="一、第一部分"><a href="#一、第一部分" class="headerlink" title="一、第一部分"></a>一、第一部分</h2><h3 id="1-MySQL的名词缩写解释"><a href="#1-MySQL的名词缩写解释" class="headerlink" title="1.MySQL的名词缩写解释"></a>1.MySQL的名词缩写解释</h3><ul><li><p>DML（data manipulation language）数据操纵语言：</p><p>就是我们最经常用到的 SELECT、UPDATE、INSERT、DELETE。 主要用来对数据库的数据进行一些操作。</p></li><li><p>DDL（data definition language）数据库定义语言：</p><p>其实就是我们在创建表的时候用到的一些sql，比如说：CREATE、ALTER、DROP等。DDL主要是用在定义或改变表的结构，数据类型，表之间的链接和约束等初始化工作上</p></li><li><p>DCL（Data Control Language）数据库控制语言：</p><p>是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。这个比较少用到。</p></li></ul><h3 id="2-DDL基础操作语句"><a href="#2-DDL基础操作语句" class="headerlink" title="2.DDL基础操作语句"></a>2.DDL基础操作语句</h3><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># DDL-数据库操作SHOW DATABASES;CREATE DATABASE 数据库名;USE 数据库名;SELECT DATABASE();DROP DATABASE 数据库名;# DDL-表操作SHOW TABLES;CREATE TABLE 表名(字段 字段类型，字段 字段类型 );DESC 表名;SHOW CREATE TABLE 表名ALTER TABLE 表名 ADD&#x2F;MODIFY&#x2F;CHANGE&#x2F;DROP&#x2F;RENAME TO ...;DROP TABLE 表名;# 添加数据INSERT INTO 表名(字段1, 字段2,...) VALUES(值1, 值2,...)[,(值1,值2,...) ...];# 修改数据UPDATE 表名 SET 字段1 &#x3D; 值1,字段2&#x3D; 值2 [WHERE 条件];# 删除数据DELETE FROM 表名[WHERE 条件];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="3-DQL基础操作语句"><a href="#3-DQL基础操作语句" class="headerlink" title="3.DQL基础操作语句"></a>3.DQL基础操作语句</h3><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># DQL-基本查询1.查询多个字段SELECT 字段1,字段2,字段3 ... FROM 表名;SELECT*FROM 表名;2.设置别名SELECT 字段1 [AS 别名1],字段2 [AS 别名2] ... FROM 表名;3.去除重复记录SELECT DISTINCT 字段列表 FROM 表名；# DQL-条件查询SELECT 字段列表 FROM 表名 WHERE 条件列表;1.查询年龄等于88的员工Select * from tb_ employee where age &#x3D; 88;2.查询年龄小于20的员工信息Select *from tb_ employee where age&lt;20;3.查询有身份证证号的员工信息Select *from tb_employee where idcard is not null;4.查询年龄在15岁（包含）到20岁（包含）之间的员工信息SELECT *from tb_employee where age&gt;&#x3D;15 and age&lt;&#x3D;20;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="4-DQL-聚合函数"><a href="#4-DQL-聚合函数" class="headerlink" title="4.DQL-聚合函数"></a>4.DQL-聚合函数</h3><h4 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1. 介绍"></a>4.1. 介绍</h4><p>将一列数据作为一个整体，进行纵向计算。</p><h4 id="4-2-常见聚合函数"><a href="#4-2-常见聚合函数" class="headerlink" title="4.2 常见聚合函数"></a>4.2 常见聚合函数</h4><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">count</td><td align="center">统计数量</td></tr><tr><td align="center">max</td><td align="center">最大值</td></tr><tr><td align="center">min</td><td align="center">最小值</td></tr><tr><td align="center">avg</td><td align="center">平均值</td></tr><tr><td align="center">sum</td><td align="center">求和</td></tr></tbody></table><h4 id="4-3-聚合函数操作语句"><a href="#4-3-聚合函数操作语句" class="headerlink" title="4.3 聚合函数操作语句"></a>4.3 聚合函数操作语句</h4><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">1.统计该企业员工数量：Select count(*) from tb_ employee;统计所有的员工的数量Select count(id_ card)from tb_ employee;统计有身份证的数量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="5-DQL-分组查询"><a href="#5-DQL-分组查询" class="headerlink" title="5.DQL-分组查询"></a>5.DQL-分组查询</h3><h4 id="4-1-语法"><a href="#4-1-语法" class="headerlink" title="4.1 语法"></a>4.1 语法</h4><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT 字段列表 FROM 表名[WHERE 条件] GROUP BY 分组字段名[HAVING 分组后过滤条件];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h4 id="4-2-where和having的区别"><a href="#4-2-where和having的区别" class="headerlink" title="4.2 where和having的区别"></a>4.2 where和having的区别</h4><ul><li>执行时机不同: where是分组之前进行过滤，不满足where条件，不参与分组;而having是分组之后对结果进行过滤。</li><li>判断条件不同:where不能对聚合函数进行判断，而having可以</li></ul><h4 id="4-3-分组查询操作语句"><a href="#4-3-分组查询操作语句" class="headerlink" title="4.3 分组查询操作语句"></a>4.3 分组查询操作语句</h4><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">1.根据性别分组，统计男性员工和女性员工的数量Select gender,count(*) from tb_ employee group by gender;2.根据性别分组，统计男性员工和女性员工的平均年龄Select gender,avg(age) from tb_employee group by gender;3.查询年龄小于45的员工，并根据工作地址分组，获取员工数量大于等于3的工作地址Select work_ address ，count(*) from tb_employee where age&lt;45 group by work_address;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="6-DQL-排序查询"><a href="#6-DQL-排序查询" class="headerlink" title="6.DQL-排序查询"></a>6.DQL-排序查询</h3><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">1.语法SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1,字段2 排序方式2;2.排序方式ASC:升序(默认值)DESC:降序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="7-DQL-分页查询"><a href="#7-DQL-分页查询" class="headerlink" title="7.DQL-分页查询"></a>7.DQL-分页查询</h3><p>注意：起始索引从0开始，起始索引 &#x3D; (查询页码-1)* 每页显示记录数分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10。</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 语法SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数1.查询第一页员工数据，每页展示10条记录SELECT *from tb_employee limit 0,10;2.查询第二页员工数据，每页展示10条数据SELECT *from tb_employee limit 10,10;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h3><h2 id="二、第二部分"><a href="#二、第二部分" class="headerlink" title="二、第二部分"></a>二、第二部分</h2><h3 id="1-事务的四大特性（ACID）"><a href="#1-事务的四大特性（ACID）" class="headerlink" title="1.事务的四大特性（ACID）"></a>1.事务的四大特性（ACID）</h3><ul><li>原子性 (Atomicity): 事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性 (Consistency) : 事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性(lsolation):数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性(Durability): 事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><h3 id="2-并发事务问题"><a href="#2-并发事务问题" class="headerlink" title="2.并发事务问题"></a>2.并发事务问题</h3><ul><li>脏读（Dirty Read）：<ul><li>脏读是指一个事务读取了另一个事务尚未提交的数据。</li><li>想象一家银行，某人正在进行取款操作，但还没有完成整个事务。同时，另一个人查看了该账户余额，看到了取款事务中的临时减少，尽管最终可能会被取消。这个过程就像读取了“脏数据”，因为它可能是不准确的。</li></ul></li><li>幻读（Phantom Read）：<ul><li>幻读是指一个事务在两次查询之间，另一个事务插入了新的数据行，导致第一个事务看到了一个似乎出现了“幻影”数据的情况。</li><li>假设一个医院管理系统中有一个正在查看某个科室的病人数量的事务。当事务开始时，有10名患者，但在事务期间，另一个事务添加了一名新患者，导致第一个事务看到了11名患者，就好像出现了“幻影”患者一样。</li><li>假如另一个事务在id&#x3D;3的地方插入数据，然后我当前事务，就是我查的时候显示id&#x3D;3明明没有数据，插入的时候却显示已经存在</li></ul></li><li>不可重复读（Non-repeatable Read）：<ul><li>不可重复读是指在同一个事务中，两次读取相同数据时，第二次读取得到的数据与第一次读取不同，这是由于其他事务修改了数据。</li><li>假设一个网上商店的顾客正在查看购物车中的商品数量。当他第一次查看时，有5件商品。然后，在他下订单之前，另一个顾客购买了2件相同的商品，导致他第二次查看购物车时，商品数量变成了3件。这就是不可重复读，因为同一事务中的两次读取返回了不同的结果。</li></ul></li></ul><h5 id="幻读和不可重复读的区别"><a href="#幻读和不可重复读的区别" class="headerlink" title="幻读和不可重复读的区别"></a>幻读和不可重复读的区别</h5><ol><li>幻读（Phantom Read）：<ul><li>幻读通常与数据行的插入或删除操作有关。它发生在一个事务在两次查询之间，另一个事务插入了新的数据行，导致第一个事务看到了一个似乎出现了“幻影”数据的情况。</li><li>幻读强调的是在事务期间其他事务添加或删除了数据，从而导致看到不一致的结果。</li></ul></li><li>不可重复读（Non-repeatable Read）：<ul><li>不可重复读通常与数据行的更新操作有关。它发生在一个事务在两次查询之间，另一个事务修改了已经存在的数据行，导致第一个事务在两次读取之间看到不同的数据。</li><li>不可重复读强调的是在事务期间其他事务修改了数据，导致读取到的数据不一致。</li></ul></li></ol><h3 id="3-事务隔离级别"><a href="#3-事务隔离级别" class="headerlink" title="3.事务隔离级别"></a>3.事务隔离级别</h3><p><img src="/2023/10/28/MySQL-%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230921162142.png"></p><ol><li>读未提交（Read Uncommitted）：<ul><li>最低的隔离级别，允许一个事务读取另一个事务未提交的数据。</li><li>可能出现脏读、幻读和不可重复读等问题。</li></ul></li><li>读已提交（Read Committed）：<ul><li>允许一个事务只能读取已提交的数据，确保不会读取到未提交的数据。</li><li>虽然可以避免脏读，但仍然可能发生幻读和不可重复读。</li></ul></li><li>可重复读（Repeatable Read）：<ul><li>事务内的多次读取都会看到相同的数据快照，即使其他事务修改了数据也不会影响。</li><li>可以避免脏读和不可重复读，但仍然可能发生幻读。</li></ul></li><li>序列化（Serializable）：<ul><li>最高的隔离级别，确保事务之间没有并发问题，所有事务顺序执行。</li><li>可以避免脏读、幻读和不可重复读，但可能会影响性能。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>基础篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java进阶-数据结构和集合源码</title>
    <link href="/2023/10/28/Java%E8%BF%9B%E9%98%B6-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    <url>/2023/10/28/Java%E8%BF%9B%E9%98%B6-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p>数据结构，就是一种程序设计优化的方法论，研究数据的、逻辑结构、和物理结构以及它们之间相互关系并对这种结构定义相应的“运算，目的是加快程序的执行速度、减少内存占用的空间。</p><h3 id="1-2研究对象之一：数据间逻辑关系"><a href="#1-2研究对象之一：数据间逻辑关系" class="headerlink" title="1.2研究对象之一：数据间逻辑关系"></a>1.2研究对象之一：数据间逻辑关系</h3><ul><li>集合结构</li><li>线性结构:一对一关系</li><li>树形结构:一对多关系</li><li>图形结构:多对多关系</li></ul><h3 id="1-3-研究对象之二：数据的存储结构"><a href="#1-3-研究对象之二：数据的存储结构" class="headerlink" title="1.3 研究对象之二：数据的存储结构"></a>1.3 研究对象之二：数据的存储结构</h3><ul><li>数组结构</li><li>链式结构</li><li>索引结构</li><li>散列结构</li></ul><h3 id="1-3-研究对象之三：运算结构"><a href="#1-3-研究对象之三：运算结构" class="headerlink" title="1.3 研究对象之三：运算结构"></a>1.3 研究对象之三：运算结构</h3><h2 id="二、常见的存储结构"><a href="#二、常见的存储结构" class="headerlink" title="二、常见的存储结构"></a>二、常见的存储结构</h2><h3 id="2-1-数组"><a href="#2-1-数组" class="headerlink" title="2.1  数组"></a>2.1  数组</h3><p>数组（Array）是一种线性数据结构，由一组连续的内存空间组成，用于存储相同类型的数据。数组可以通过索引直接访问任何元素，其读取和写入的时间复杂度均为 O(1)。</p><h3 id="2-2-链表"><a href="#2-2-链表" class="headerlink" title="2.2 链表"></a>2.2 链表</h3><p>链表（Linked List）是另一种常见的数据结构，它由一系列节点组成，每个节点包含数据部分和指向下一个节点的指针。链表分为单向链表和双向链表，其优点是可以高效地插入和删除元素，但访问特定位置的元素的时间复杂度较高。</p><h3 id="2-3-树"><a href="#2-3-树" class="headerlink" title="2.3 树"></a>2.3 树</h3><p>树（Tree）是一种层次化的数据结构，由节点和边组成。树结构具有根节点、子节点和父节点等概念。常见的树包括二叉树、二叉搜索树、平衡树等。树结构常用于搜索算法和数据检索中。</p><ul><li>二叉树（Binary Tree）：二叉树是每个节点最多只有两个子节点的树结构。通常分为左子树和右子树。二叉树的子树有左右之分，且次序不能颠倒。</li><li>二叉搜索树（Binary Search Tree）：二叉搜索树是一种特殊的二叉树，其中每个节点的左子树中的值都小于该节点的值，而右子树中的值都大于该节点的值。这使得二叉搜索树成为一种有效的数据结构，用于快速搜索、插入和删除操作。</li><li>平衡树（Balanced Tree）：平衡树是一种树，其中任意节点的两个子树的高度差不大于1。它的目的是为了维护树的平衡，从而保证树的查找、插入和删除等操作的效率。</li><li>B树（B-Tree）：B树是一种自平衡的树结构，通常用于组织文件系统和数据库中的数据。B树具有多个子树，允许每个节点有多个子节点。B树在处理大量数据时表现出良好的性能。</li><li>红黑树（Red-Black Tree）：红黑树是一种自平衡的二叉搜索树，它在每个节点上增加了一个存储位来表示节点的颜色，可以是红色或黑色。红黑树具有一些特定的规则来确保树始终保持平衡，从而保证了较高的性能。</li></ul><h3 id="2-4-栈"><a href="#2-4-栈" class="headerlink" title="2.4 栈"></a>2.4 栈</h3><p>栈（Stack）是一种遵循后进先出（LIFO）原则的数据结构。栈的插入和删除操作均发生在栈顶。常见的栈操作包括压栈（push）和弹栈（pop），用于许多计算机应用程序的实现，如表达式求值、函数调用等。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Stack</span><span class="token punctuation">&#123;</span>  <span class="token comment">//用数组实现</span>    <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values<span class="token punctuation">;</span>    <span class="token keyword">int</span> size <span class="token punctuation">;</span> <span class="token comment">//记录存储的元素的个数</span>    <span class="token keyword">public</span> <span class="token class-name">Stack</span><span class="token punctuation">(</span><span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        valus <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//入栈</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">Object</span> ele<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">>=</span> values<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"栈空间已满，入栈失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        values<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> ele<span class="token punctuation">;</span>        size <span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//出栈</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">&lt;</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"栈空间已空,出栈失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">Object</span> obj <span class="token operator">=</span> values<span class="token punctuation">[</span>size <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        values<span class="token punctuation">[</span>size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        size <span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> obj<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="2-5队列"><a href="#2-5队列" class="headerlink" title="2.5队列"></a>2.5队列</h3><p>队列（Queue）是一种遵循先进先出（FIFO）原则的数据结构。队列的插入操作（入队）发生在队尾，删除操作（出队）发生在队首。队列常用于处理按顺序进行的任务，如打印任务、CPU任务调度等。</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Queue</span><span class="token punctuation">&#123;</span>  <span class="token comment">//用数组实现</span>    <span class="token class-name">Object</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> values<span class="token punctuation">;</span>    <span class="token keyword">int</span> size<span class="token punctuation">;</span> <span class="token comment">//记录存储的元素的个数</span>    <span class="token comment">//入队</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Object</span> ele<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token operator">=</span> valus<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"队列已满，添加失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        values<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> ele<span class="token punctuation">;</span>         size <span class="token operator">++</span> <span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//出队</span>    <span class="token keyword">public</span> <span class="token class-name">Objext</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>size<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"队列已空，获取失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">Object</span> obj <span class="token operator">=</span> values<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>i<span class="token operator">&lt;</span> size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            values<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> values<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//最后一个元素置空</span>        values<span class="token punctuation">[</span>size <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        size<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> obj<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="三、List实现类源码分析"><a href="#三、List实现类源码分析" class="headerlink" title="三、List实现类源码分析"></a>三、List实现类源码分析</h2><h3 id="3-1-Arraylist源码解析："><a href="#3-1-Arraylist源码解析：" class="headerlink" title="3.1.Arraylist源码解析："></a>3.1.Arraylist源码解析：</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//jdk7.0 版本</span><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//底层会初始化数组，数组长度的为10</span><span class="token comment">//添加元素</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"AA"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//可以添加10个，当满10的时候再添加会默认扩容为原来的1.5倍</span><span class="token comment">//jdk8.0版本</span><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化数组的时候为空</span><span class="token comment">//添加元素</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"AA"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//当添加元素的时候会初始化数组，让它的长度为10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="3-2-Vector源码解析："><a href="#3-2-Vector源码解析：" class="headerlink" title="3.2.Vector源码解析："></a>3.2.Vector源码解析：</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//JDK 1.8</span><span class="token class-name">Vector</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//底层初始化数组，长度为10</span>v<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"AA"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>v<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"BB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//当添加到11个的时候，需要扩容，底层默认扩容2倍</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="3-3-LinkedList-源码解析："><a href="#3-3-LinkedList-源码解析：" class="headerlink" title="3.3. LinkedList 源码解析："></a>3.3. LinkedList 源码解析：</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//没有初始化容量</span>list<span class="token punctuation">,</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"AA"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将"AA"封装到一个Node对象1中，ist对象的属性first、last都指向此Node对象1。</span><span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"BB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将"BB"封装到一个Node对象2中，对象1和对象2构成一个双向链表，同时last指向此Node对象2</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//因为LinkedList使用的是双向链表，不需要考虑扩容问题</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="四、Map实现类源码分析"><a href="#四、Map实现类源码分析" class="headerlink" title="四、Map实现类源码分析"></a>四、Map实现类源码分析</h2><h3 id="4-1-HashMap源码分析"><a href="#4-1-HashMap源码分析" class="headerlink" title="4.1.HashMap源码分析"></a>4.1.HashMap源码分析</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//JDK 1.7</span><span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span>map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建对象的过程中，底层会初始化数组Entry[]table = new Entry[16];</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"AA"</span><span class="token punctuation">,</span><span class="token number">78</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"AA"和78封装到一个Entry对象中，考虑将此对象添加到table数组中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>添加&#x2F;修改过程</p><p>将(key1,value1)添加到当前的map中:<br>首先，需要调用key1所在类的hashCode()方法，计算key1对应的哈希值1，此哈希值1经过某种算法(hash())之后，得到哈希值2。<br>哈希值2再经过某种算法(indexFor())之后，就确定了(key1,value1)在数组table中的索引位置i。</p><ol><li>​如果此索引位置i的数组上没有元素，则(key1,value1)添加成功。 —-&gt;情况1</li><li>​如果此索引位置i的数组上有元素(key2,value2),则需要继续比较key1和key2的哈希值2 —&gt;哈希冲突<ol><li>如果key1的哈希值2与key2的哈希值2不相同，则(key1,value1)添加成功。—-&gt;情况2</li><li>如果key1哈希值2与key2的哈值2相同，则需要继续比较key1和key2的equaLs()。要调用key1所在类的equals()将key2作为参数传递进去.<ol><li>调用equals()，返回fase: 则(key1,value1)添加成功。—-&gt;情况3</li><li>调用equals()，返回true: 则认为key1和key2是相同的。默认情况下，value1替换原有的value2。</li></ol></li></ol></li></ol><p>说明：情况1:将(key1,value1)存放到数组的索引i的位置<br>            情况2,情况3: (key1,value1)元素与现有的(key2,value2)构成单向链表结构，(key1,value1)指向(key2,value2)</p><p>随着不断的添加元素，在满足如下的条件的情况下，会考虑扩容:</p><p>(size &gt;&#x3D; threshold) &amp;&amp; (null !&#x3D; table[i])</p><p>当元素的个数达到临界值(-&gt;数组的长度 * 加载因子)时，就考虑扩容。默认的临界值 &#x3D; 16*0.75 –&gt; 12.</p><p>默认扩容为原来的2倍</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//jdk 1.8</span><span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span>map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建对象的过程中，底层不会初始化table数组</span><span class="token comment">//当首次往map添加key-value值得时候，进行判断如果发现table未初始化，则进行初始化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>2.2 jdk8与jdk7的不同之处(以jdk1.8._271为例):</p><ol><li>在jdk8中，当我们创建了HashMap实例以后，底层并没有初始化table数组。当首次添加(key,value)时，进行判断如果发现table尚未初始化，则对数组进行初始化。</li><li>在jdk8中，HashMap底层定义了Node内部类，替换jdk7中的Entry内部类。意味着，我们创建的数组是Node[ ]</li><li>在jdk8中，如果当前的(key,value)经过一系列判断之后，可以添加到当前的数组角标i中。如果此时角标i位置上有元素。在jdk7中是将新的(key,value)指向已有的旧的元素(头插法)，而在jdk8中是旧的元素指向新的(key,value)元素(尾插法)。”七上八下”</li><li>jdk7:数组+单向链表<br>jdk8:数组+单向链表+ 红黑树</li></ol><ul><li>什么时候会使用单向链表变为红黑树:如果数组索引i位置上的元素的个数达到8，并且数组的长度达到64时，我们就将此索引i位置上的多个元素改为使用红黑树的结构进行存储。 (为什么修改呢? 红黑树进行put()&#x2F;get()&#x2F;remove操作的时间复杂度为0(logn)，比单向链表的时间复杂度(n)的好。性能更高。</li><li>什么时候会使用红黑树变为单向链表:当使用红黑树的索引i位置上的元素的个数低于6的时候，就会将红黑树结构退化为单向链表</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构</tag>
      
      <tag>集合源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>天机学堂-基础环境搭建</title>
    <link href="/2023/10/28/tianji/"/>
    <url>/2023/10/28/tianji/</url>
    
    <content type="html"><![CDATA[<h2 id="1、写在最前"><a href="#1、写在最前" class="headerlink" title="1、写在最前"></a>1、写在最前</h2><ul><li>完整项目地址：</li></ul><h2 id="2、项目背景"><a href="#2、项目背景" class="headerlink" title="2、项目背景"></a>2、项目背景</h2><h3 id="2-1-在线教育市场环境"><a href="#2-1-在线教育市场环境" class="headerlink" title="2.1 在线教育市场环境"></a>2.1 在线教育市场环境</h3><h3 id="2-2-项目背景"><a href="#2-2-项目背景" class="headerlink" title="2.2 项目背景"></a>2.2 项目背景</h3><h2 id="3、项目介绍"><a href="#3、项目介绍" class="headerlink" title="3、项目介绍"></a>3、项目介绍</h2><h3 id="3-1-项目介绍"><a href="#3-1-项目介绍" class="headerlink" title="3.1 项目介绍"></a>3.1 项目介绍</h3><h3 id="3-2-功能模块与演示"><a href="#3-2-功能模块与演示" class="headerlink" title="3.2 功能模块与演示"></a>3.2 功能模块与演示</h3><h3 id="3-3-面试"><a href="#3-3-面试" class="headerlink" title="3.3 面试"></a>3.3 面试</h3><h2 id="4、项目技术架构"><a href="#4、项目技术架构" class="headerlink" title="4、项目技术架构"></a>4、项目技术架构</h2><h3 id="4-1项目技术架构"><a href="#4-1项目技术架构" class="headerlink" title="4.1项目技术架构"></a>4.1项目技术架构</h3><h3 id="4-2项目技术栈"><a href="#4-2项目技术栈" class="headerlink" title="4.2项目技术栈"></a>4.2项目技术栈</h3><h2 id="5、项目开发环境搭建"><a href="#5、项目开发环境搭建" class="headerlink" title="5、项目开发环境搭建"></a>5、项目开发环境搭建</h2><p>5.1项目工程搭建</p>]]></content>
    
    
    <categories>
      
      <category>天机学堂</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>缓存穿透，缓存击穿，缓存雪崩区别</title>
    <link href="/2023/10/28/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/10/28/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>发现自己有时候明明已经做过了，可能是缺少回顾总结，过了几天这部分知识就会忘的一干二净，一点有记不住，还有这三个概念有时候确实不太能把他分清楚，面试的时候也有让自己说清楚，说的一塌糊涂，所以总结一下</p></blockquote><h2 id="一、缓存穿透，缓存击穿，缓存雪崩简单的区别"><a href="#一、缓存穿透，缓存击穿，缓存雪崩简单的区别" class="headerlink" title="一、缓存穿透，缓存击穿，缓存雪崩简单的区别"></a>一、缓存穿透，缓存击穿，缓存雪崩简单的区别</h2><p><strong>缓存穿透</strong>是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会失效，请求都会打到数据库</p><p><strong>缓存击穿</strong>问题也叫做热点key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问回给瞬间的数据库带来巨大的冲击</p><p><strong>缓存雪崩</strong>是指同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><h2 id="二、缓存穿透"><a href="#二、缓存穿透" class="headerlink" title="二、缓存穿透"></a>二、缓存穿透</h2><p>缓存穿透常见的解决方案有两种：</p><h3 id="1-缓存空对象"><a href="#1-缓存空对象" class="headerlink" title="1.缓存空对象"></a>1.缓存空对象</h3><ul><li>优点：实现简单，维护简单</li><li>缺点：额外的内存消耗，可能造成短期的不一致</li></ul><p><img src="/2023/10/28/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%8C%BA%E5%88%AB/workspace\ImShanks.github.io\source_posts\images\微信截图_20230919213949.png" alt="微信截图_20230919213949"></p><h3 id="2-布隆过滤"><a href="#2-布隆过滤" class="headerlink" title="2.布隆过滤"></a>2.布隆过滤</h3><ul><li>优点：内存占用较少，没有多余的key</li><li>缺点：实现复杂，存在误判的可能</li></ul><p><img src="/2023/10/28/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%8C%BA%E5%88%AB/workspace\ImShanks.github.io\source_posts\images\微信截图_20230919214158.png" alt="微信截图_20230919214158"></p><p>3.解决缓存穿透的代码实现</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">,</span>ID<span class="token punctuation">></span></span> <span class="token class-name">R</span> <span class="token function">queryWithPassThrough</span><span class="token punctuation">(</span>          <span class="token class-name">String</span> keyPrefix<span class="token punctuation">,</span> <span class="token class-name">ID</span> id<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">></span></span> type<span class="token punctuation">,</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span>ID<span class="token punctuation">,</span><span class="token class-name">R</span><span class="token punctuation">></span></span> dbFallBack<span class="token punctuation">,</span><span class="token class-name">Long</span> time <span class="token punctuation">,</span><span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token comment">//1.查询缓存</span>      <span class="token class-name">String</span> key <span class="token operator">=</span> keyPrefix <span class="token operator">+</span> id<span class="token punctuation">;</span>      <span class="token class-name">String</span> <span class="token class-name">Json</span> <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//2.判断缓存是否存在</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isNotBlank</span><span class="token punctuation">(</span><span class="token class-name">Json</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token comment">//2.1 如果存在则直接返回数据给用户</span>          <span class="token keyword">return</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span><span class="token class-name">Json</span><span class="token punctuation">,</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">Json</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">//3.缓存不存在，查询数据库</span>      <span class="token class-name">R</span> r <span class="token operator">=</span> dbFallBack<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//3.1如果数据库中也不存在，则返回错误信息</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token comment">//将一个“”空字符串直接存到redis中</span>          stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token constant">CACHE_NULL_TTL</span><span class="token punctuation">,</span><span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">//4.将数据库中的数据存入redis</span>     <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>r<span class="token punctuation">,</span>time<span class="token punctuation">,</span>unit<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//5.返回</span>      <span class="token keyword">return</span> r<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="三、缓存击穿"><a href="#三、缓存击穿" class="headerlink" title="三、缓存击穿"></a>三、缓存击穿</h2><p>缓存击穿有两种常见的解决方法：</p><h3 id="1-互斥锁"><a href="#1-互斥锁" class="headerlink" title="1.互斥锁"></a>1.互斥锁</h3><p><img src="/2023/10/28/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%8C%BA%E5%88%AB/workspace\ImShanks.github.io\source_posts\images\微信截图_20230919214726.png" alt="微信截图_20230919214726"></p><h3 id="2-逻辑过期"><a href="#2-逻辑过期" class="headerlink" title="2.逻辑过期"></a>2.逻辑过期</h3><p><img src="/2023/10/28/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%8C%BA%E5%88%AB/workspace\ImShanks.github.io\source_posts\images\微信截图_20230919214744.png" alt="微信截图_20230919214744"></p><h3 id="3-两者的优缺点"><a href="#3-两者的优缺点" class="headerlink" title="3.两者的优缺点"></a>3.两者的优缺点</h3><p><img src="/2023/10/28/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%8C%BA%E5%88%AB/workspace\ImShanks.github.io\source_posts\images\微信截图_20230919214832.png" alt="微信截图_20230919214832"></p><h3 id="4-互斥锁的代码实现"><a href="#4-互斥锁的代码实现" class="headerlink" title="4.互斥锁的代码实现"></a>4.互斥锁的代码实现</h3><p>流程图</p><p><img src="/2023/10/28/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%8C%BA%E5%88%AB/workspace\ImShanks.github.io\source_posts\images\微信截图_20230919215243.png" alt="微信截图_20230919215243"></p><p>代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">  <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">,</span>ID<span class="token punctuation">></span></span><span class="token class-name">R</span> <span class="token function">queryWithMutex</span><span class="token punctuation">(</span>            <span class="token class-name">String</span> keyprefix<span class="token punctuation">,</span><span class="token class-name">String</span> lockKeyPrefix<span class="token punctuation">,</span><span class="token class-name">ID</span> id<span class="token punctuation">,</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">></span></span>type<span class="token punctuation">,</span><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span>ID<span class="token punctuation">,</span><span class="token class-name">R</span><span class="token punctuation">></span></span>dbFallBack<span class="token punctuation">,</span><span class="token class-name">Long</span> time <span class="token punctuation">,</span><span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>        <span class="token comment">//1.查询缓存</span>        <span class="token class-name">String</span> key <span class="token operator">=</span> keyprefix <span class="token operator">+</span> id<span class="token punctuation">;</span>        <span class="token class-name">String</span> <span class="token class-name">Json</span> <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.判断缓存是否存在</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isNotBlank</span><span class="token punctuation">(</span><span class="token class-name">Json</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//2.1 如果存在则直接返回数据给用户</span>            <span class="token keyword">return</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span><span class="token class-name">Json</span><span class="token punctuation">,</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">Json</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//当缓存的内容不是空字符串""的时候</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//2.2 缓存不是空字符串""，而是不存在时进行缓存重建</span>        <span class="token comment">//3.缓存重建</span>        <span class="token comment">//3.1获取互斥锁</span>        <span class="token class-name">String</span> lockKey <span class="token operator">=</span> lockKeyPrefix <span class="token operator">+</span>id<span class="token punctuation">;</span>        <span class="token class-name">R</span> r <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token function">tryLock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//3.2判断是否获取互斥锁成功</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">//获取互斥锁失败</span>                <span class="token comment">//3.3失败则休眠并且重试</span>                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token function">queryWithMutex</span><span class="token punctuation">(</span>keyprefix<span class="token punctuation">,</span>lockKeyPrefix<span class="token punctuation">,</span>id<span class="token punctuation">,</span>type<span class="token punctuation">,</span>dbFallBack<span class="token punctuation">,</span>time<span class="token punctuation">,</span>unit<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//3.4成功则进行查询数据库</span>            <span class="token comment">//4.缓存不存在，查询数据库</span>            r <span class="token operator">=</span> dbFallBack<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//模拟重建的延时</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//4.1如果数据库中也不存在，则返回错误信息</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token constant">CACHE_NULL_TTL</span><span class="token punctuation">,</span><span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//5.将数据库中的数据存入redis</span>            stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toJsonStr</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span>time<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//6.释放互斥锁</span>            <span class="token function">unLock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//7.返回</span>        <span class="token keyword">return</span> r<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">/**     * 开启锁     * @param key     * @return     */</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Boolean</span> flag <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token constant">LOCK_SHOP_TTL</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">BooleanUtil</span><span class="token punctuation">.</span><span class="token function">isTrue</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 解锁     * @param key     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="5-逻辑过期的代码实现"><a href="#5-逻辑过期的代码实现" class="headerlink" title="5.逻辑过期的代码实现"></a>5.逻辑过期的代码实现</h3><p>流程图</p><p><img src="/2023/10/28/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%8C%BA%E5%88%AB/workspace\ImShanks.github.io\source_posts\images\微信截图_20230919220624.png" alt="微信截图_20230919220624"></p><p>代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">,</span>ID<span class="token punctuation">></span></span><span class="token class-name">R</span> <span class="token function">queryWithLogicalExpire</span><span class="token punctuation">(</span>           <span class="token class-name">String</span> keyprefix<span class="token punctuation">,</span><span class="token class-name">String</span> lockKeyPrefix<span class="token punctuation">,</span><span class="token class-name">ID</span> id<span class="token punctuation">,</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">></span></span>type<span class="token punctuation">,</span><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span>ID<span class="token punctuation">,</span><span class="token class-name">R</span><span class="token punctuation">></span></span>dbFallBack<span class="token punctuation">,</span><span class="token class-name">Long</span> time <span class="token punctuation">,</span><span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       <span class="token comment">//1.查询缓存</span>       <span class="token class-name">String</span> key <span class="token operator">=</span> keyprefix <span class="token operator">+</span> id<span class="token punctuation">;</span>       <span class="token class-name">String</span> <span class="token class-name">Json</span> <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//2.判断缓存是否为空</span>       <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span><span class="token class-name">Json</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>           <span class="token comment">//Json为空，直接返回给用户null</span>           <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>       <span class="token comment">//2.1命中，需要先把json反序列化为对象</span>       <span class="token class-name">RedisData</span> redisData <span class="token operator">=</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span><span class="token class-name">Json</span><span class="token punctuation">,</span> <span class="token class-name">RedisData</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">R</span> r <span class="token operator">=</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">JSONObject</span><span class="token punctuation">)</span> redisData<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">LocalDateTime</span> expireTime <span class="token operator">=</span> redisData<span class="token punctuation">.</span><span class="token function">getExpireTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//2.2判断逻辑时间是否已经过期</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>expireTime<span class="token punctuation">.</span><span class="token function">isAfter</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>           <span class="token comment">//expireTime在当前时间之后，说明还没过期</span>           <span class="token keyword">return</span> r<span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>       <span class="token comment">//3当逻辑时间已经过期,需要缓存重建</span>       <span class="token comment">//3.1获取互斥锁</span>       <span class="token class-name">String</span> lockKey <span class="token operator">=</span> lockKeyPrefix <span class="token operator">+</span> id<span class="token punctuation">;</span>       <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token function">tryLock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//判断是否获取锁成功</span>       <span class="token keyword">if</span><span class="token punctuation">(</span> flag<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>           <span class="token comment">//开启缓存重建,开启独立线程重建</span>           <span class="token constant">CACHE_REBULID_EXECUTOR</span><span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span>               <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                   <span class="token comment">//先查数据库</span>                   <span class="token class-name">R</span> r1 <span class="token operator">=</span> dbFallBack<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">//2.封装逻辑过期时间</span>                   <span class="token class-name">RedisData</span> redisData1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">RedisData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   redisData1<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>r1<span class="token punctuation">)</span><span class="token punctuation">;</span>                   redisData1<span class="token punctuation">.</span><span class="token function">setExpireTime</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">plusSeconds</span><span class="token punctuation">(</span>unit<span class="token punctuation">.</span><span class="token function">toSeconds</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">//再写入Redis</span>                   stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span><span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toJsonStr</span><span class="token punctuation">(</span>redisData<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                   <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">&#125;</span><span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                   <span class="token comment">//释放锁</span>                   <span class="token function">unLock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">&#125;</span>           <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>       <span class="token comment">//4.返回</span>       <span class="token keyword">return</span> r<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token comment">/**    * 开启锁    * @param key    * @return    */</span>   <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       <span class="token class-name">Boolean</span> flag <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token constant">LOCK_SHOP_TTL</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> <span class="token class-name">BooleanUtil</span><span class="token punctuation">.</span><span class="token function">isTrue</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token comment">/**    * 解锁    * @param key    */</span>   <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       stringRedisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="四、缓存雪崩"><a href="#四、缓存雪崩" class="headerlink" title="四、缓存雪崩"></a>四、缓存雪崩</h2><p>1.<strong>缓存雪崩</strong>是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>2.<strong>解决方案</strong>:</p><ul><li>给不同的Key的TTL添加随机值</li><li>利用Redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
